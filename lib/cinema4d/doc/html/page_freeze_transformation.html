<!-- HTML header -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>Freeze Transformation : Melange 19.0 SDK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<link href="msearch/css/msearch.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="msearch/js/msearch.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->

</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_freeze_transformation.html','');});
</script>
<div id="doc-content">


<div class="header">
  <div class="headertitle">
<div class="title">Freeze Transformation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#section_freezetransformation_example">Example</a></li>
<li class="level1"><a href="#section_freezetransformation_mathematicalbackground">Mathematical Background</a></li>
</ul>
</div>
<div class="textblock"><p>Since R12 <em>Cinema&#160;4D</em> uses Freeze Transformation and <a class="el" href="classmelange_1_1_base_object.html">BaseObject</a> no longer has members like <code>GetPos()</code>, but instead twice as many: <a class="el" href="classmelange_1_1_base_object.html#a55255b345fafd9984a3ba3c734bbc60e">GetRelPos()</a> and <a class="el" href="classmelange_1_1_base_object.html#a79607def0b616076c1d0eb585d628d14">GetAbsPos()</a>.</p>
<p>For character animation it is important to be able to define rest poses. Think e.g. of the typical CG human that has arms and legs stretched.<br />
Most objects carry all kinds of complicated position, scale and rotation information. Freeze Transformation allows to "freeze" this information, but reset position/rotation to <em>0.0</em> and scale to <em>1.0</em>.<br />
This is great as it allows at any time to go back to the original (reset all position and angle information to <em>0.0</em>) and object has reached its rest state again.</p>
<p>The same could be achieved by adding for every single object in a hierarchy a parent null object, but Freeze Transformation let do this without the need to change the hierarchical structure.<br />
Technically however think of it as a "parent null object" without the actual body of a physical object.</p>
<p>All parts of the application that deal with keyframing only access values without the Freeze Transformation part.<br />
This way it is possible to conveniently animate (the rest pose is always <em>0.0</em> for position and rotation) and avoid rotation singularities.<br />
The correct routines for animation and keyframing are labeled "Rel".</p>
<p>Other parts of the application however (e.g. like a target expression) need to get the absolute local position of a target.<br />
For those purposes use the routines that are labeled "Abs".</p>
<p>As long as an object has no Freeze Transformation assigned (which is always the default case when a new object is created) there is no difference between "Abs" or "Rel".<br />
So e.g. after calling <a class="el" href="classmelange_1_1_base_object.html#a2c141414d2108667a363f2c270991363">BaseObject::Alloc()</a> it does not matter which routine is called.</p>
<p><a class="el" href="classmelange_1_1_base_object.html#a24020aab1151ba0a4e70ad58ee299fb1">BaseObject::GetMl()</a>/<a class="el" href="classmelange_1_1_base_object.html#a39174769b6f3af2af192d86dda562809">BaseObject::SetMl()</a> and <a class="el" href="classmelange_1_1_base_object.html#ad8e131772e4496cffe82ccadc07fe6df">BaseObject::GetMg()</a>/<a class="el" href="classmelange_1_1_base_object.html#a193c99b8459c487b0669caadb1dc3209">BaseObject::SetMg()</a> always include the frozen information, thus are "Abs" versions.</p>
<h1><a class="anchor" id="section_freezetransformation_example"></a>
Example</h1>
<p>After so much theory a practical example. Take a look at the Null object and Cube in the picture below.<br />
The Null object has a position of <em>(0/200/0)</em> and rotation of <em>(0&deg;/45&deg;/0&deg;)</em>. Cube has a position of <em>(0/100/0)</em>.</p>
<div class="image">
<img src="freezetransformation_null.png" alt="freezetransformation_null.png"/>
</div>
<p>The same with one single object:</p>
<div class="image">
<img src="freezetransformation.png" alt="freezetransformation.png"/>
</div>
<p>The Null object's position and rotation have been transferred to the Cube's frozen position and frozen rotation.<br />
The result is exactly the same as before, just without the need for an extra Null object.</p>
<p><code>cube-&gt;GetAbsPos()</code> returns <em>(0/270.711/-70.711)</em> and <code>cube-&gt;GetRelPos()</code> returns <em>(0/100/0)</em>. The Coordinate Manager offers exactly those two display modes: Object (Abs) and Object (Rel).</p>
<p>If <a class="el" href="classmelange_1_1_private_chunk.html#a67e1c382388a151888d7b170963ed821">BaseObject::GetParameter()</a> and <a class="el" href="classmelange_1_1_private_chunk.html#ac9f1ec1bfe738c94a3282025752f9cba">BaseObject::SetParameter()</a> are used to access the position the same distinction exists: there is <code>ID_BASEOBJECT_REL_POSITION</code> and <code>ID_BASEOBJECT_ABS_POSITION</code> (along with <code>ID_BASEOBJECT_FROZEN_POSITION</code>).</p>
<p>To copy position, rotation and scale data from one object to another use <a class="el" href="classmelange_1_1_base_object.html#ad14aaebe85d11afc324b691ca443dc91">BaseObject::CopyMatrixTo()</a> that copies all position, rotation and scale data (including the frozen states).</p>
<h1><a class="anchor" id="section_freezetransformation_mathematicalbackground"></a>
Mathematical Background</h1>
<p>Let's take a look at the mathematical background.<br />
In <em>Cinema&#160;4D</em> the matrix multiplication order for two matrices A and B is defined as the rule "A after B": </p><pre class="fragment">[C] = [A] * [B]
</pre><p> So the following two lines are equivalent: </p><pre class="fragment">transformed_point = original_point * [C]
transformed_point = (original_point * [B]) * [A]
</pre><p> The original point is first transformed by matrix <code>[B]</code> and then later by <code>[A]</code>. An object's global matrix is calculated this way: </p><pre class="fragment">[Global Matrix] = [Global Matrix of Parent] * [Local Matrix]
</pre><p> or </p><pre class="fragment">Matrix mg = op-&gt;GetUpMg() * op-&gt;GetMl();
</pre><p> To calculate the local matrix of an object the formula is: </p><pre class="fragment">[Local Matrix] = [Frozen Translation] * [Frozen Rotation] * [Relative Translation] * [Relative Rotation] * [Frozen Scale] * [Relative Scale]
</pre><p> or </p><pre class="fragment">Matrix ml = MatrixMove(op-&gt;GetFrozenPos()) * HPBToMatrix(op-&gt;GetFrozenRot()) * MatrixMove(op-&gt;GetRelPos()) * HPBToMatrix(op-&gt;GetRelRot()) * MatrixScale(op-&gt;GetFrozenScale) * MatrixScale(op-&gt;GetRelScale());
</pre><p> or </p><pre class="fragment">Matrix ml = MatrixMove(op-&gt;GetAbsPos()) * HPBToMatrix(op-&gt;GetAbsRot()) * MatrixScale(op-&gt;GetAbsScale);
</pre><dl class="section note"><dt>Note</dt><dd>The both scales are applied at the very beginning, so the local matrix is not the same as <code>[Frozen Matrix]</code> * <code>[Relative Matrix]</code>.<br />
This is necessary in order to guarantee that the local matrix always stays a rectangular system; distorted systems are too complicated to handle. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer -->
<!-- start footer part -->
<div id="nav-path" class="navpath"> <!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2017 MAXON Computer GmbH. Visit <a href="https://developers.maxon.net/" target="_blank" style="text-decoration:underline;">developers.maxon.net</a> for the latest version. Last updated on Fri Nov 17 2017</li>
  </ul>
</div>
</body>
</html>
<!-- end footer part -->