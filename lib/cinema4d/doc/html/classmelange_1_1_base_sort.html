<!-- HTML header -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>BaseSort&lt; SORTCLASS, FLAGS &gt; Class Template Reference : Melange 19.0 SDK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<link href="msearch/css/msearch.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="msearch/js/msearch.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->

</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmelange_1_1_base_sort.html','');});
</script>
<div id="doc-content">


<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classmelange_1_1_base_sort-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BaseSort&lt; SORTCLASS, FLAGS &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__group__maxondatastructures.html">MAXON Data Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;sort.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3dcc9c3a029b9332faa0aba1dc1937c4"><td class="memTemplParams" colspan="2">template&lt;typename ITERATOR &gt; </td></tr>
<tr class="memitem:a3dcc9c3a029b9332faa0aba1dc1937c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmelange_1_1_base_sort.html#a3dcc9c3a029b9332faa0aba1dc1937c4">Sort</a> (ITERATOR start, ITERATOR end) const</td></tr>
<tr class="separator:a3dcc9c3a029b9332faa0aba1dc1937c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7197dc59baf9bc383c3a4c945ce531"><td class="memTemplParams" colspan="2">template&lt;typename ITERATOR &gt; </td></tr>
<tr class="memitem:aaa7197dc59baf9bc383c3a4c945ce531"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmelange_1_1_base_sort.html#aaa7197dc59baf9bc383c3a4c945ce531">Sort</a> (ITERATOR start, <a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> count) const</td></tr>
<tr class="separator:aaa7197dc59baf9bc383c3a4c945ce531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747eed6bc2c1e89b92afa56cf9a80661"><td class="memTemplParams" colspan="2">template&lt;typename ARRAY &gt; </td></tr>
<tr class="memitem:a747eed6bc2c1e89b92afa56cf9a80661"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmelange_1_1_base_sort.html#a747eed6bc2c1e89b92afa56cf9a80661">Sort</a> (ARRAY &amp;arr) const</td></tr>
<tr class="separator:a747eed6bc2c1e89b92afa56cf9a80661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bf1eb9bae6ace3de66327dd79a9cee"><td class="memTemplParams" colspan="2">template&lt;typename SEARCHTYPE , typename ITERATOR &gt; </td></tr>
<tr class="memitem:a24bf1eb9bae6ace3de66327dd79a9cee"><td class="memTemplItemLeft" align="right" valign="top">ITERATOR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmelange_1_1_base_sort.html#a24bf1eb9bae6ace3de66327dd79a9cee">Find</a> (const SEARCHTYPE &amp;key, ITERATOR arr, <a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> count) const</td></tr>
<tr class="separator:a24bf1eb9bae6ace3de66327dd79a9cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973efa4af8b35cc0e0e5a2bab263d998"><td class="memTemplParams" colspan="2">template&lt;typename ARRAY , typename SEARCHTYPE &gt; </td></tr>
<tr class="memitem:a973efa4af8b35cc0e0e5a2bab263d998"><td class="memTemplItemLeft" align="right" valign="top">ARRAY::ValueType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmelange_1_1_base_sort.html#a973efa4af8b35cc0e0e5a2bab263d998">Find</a> (const SEARCHTYPE &amp;key, const ARRAY &amp;arr) const</td></tr>
<tr class="separator:a973efa4af8b35cc0e0e5a2bab263d998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b4298b0710bcae7838837b4aa78880"><td class="memTemplParams" colspan="2">template&lt;typename SEARCHTYPE , typename ITERATOR &gt; </td></tr>
<tr class="memitem:aa1b4298b0710bcae7838837b4aa78880"><td class="memTemplItemLeft" align="right" valign="top">ITERATOR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmelange_1_1_base_sort.html#aa1b4298b0710bcae7838837b4aa78880">FindInsertionIndex</a> (const SEARCHTYPE &amp;key, ITERATOR arr, <a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> count, <a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> &amp;insertionIndex) const</td></tr>
<tr class="separator:aa1b4298b0710bcae7838837b4aa78880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89075b16850204f451a683e67aea6b2d"><td class="memTemplParams" colspan="2">template&lt;typename ARRAY , typename SEARCHTYPE &gt; </td></tr>
<tr class="memitem:a89075b16850204f451a683e67aea6b2d"><td class="memTemplItemLeft" align="right" valign="top">ARRAY::ValueType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmelange_1_1_base_sort.html#a89075b16850204f451a683e67aea6b2d">FindInsertionIndex</a> (const SEARCHTYPE &amp;key, const ARRAY &amp;arr, <a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> &amp;insertionIndex) const</td></tr>
<tr class="separator:a89075b16850204f451a683e67aea6b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae1df894890ba9c7eda8d5eaaea2fdbb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmelange_1_1_base_sort.html#ae1df894890ba9c7eda8d5eaaea2fdbb3">Log2</a> (<a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> n) const</td></tr>
<tr class="separator:ae1df894890ba9c7eda8d5eaaea2fdbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40a14bb5568ddb92c391eaeedb46cea"><td class="memTemplParams" colspan="2">template&lt;typename ITERATOR , typename CONTENT &gt; </td></tr>
<tr class="memitem:ad40a14bb5568ddb92c391eaeedb46cea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmelange_1_1_base_sort.html#ad40a14bb5568ddb92c391eaeedb46cea">ISort</a> (ITERATOR start, <a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> count, const CONTENT &amp;valType) const</td></tr>
<tr class="separator:ad40a14bb5568ddb92c391eaeedb46cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename SORTCLASS, BASESORTFLAGS FLAGS = BASESORTFLAGS_0&gt;<br />
class melange::BaseSort&lt; SORTCLASS, FLAGS &gt;</h3>

<p>Template for sorting arrays and searching in sorted arrays</p>
<p>To use this template derive a class from it and define the member 'LessThan' that implements an element comparison. If you do searching the member 'IsEqual' needs to be implemented that does an element comparison with the search key as the first argument. If the search key is different from the element type a second LessThan routine is needed (comparing SEARCHKEY to an element).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SORTCLASS</td><td>The class itself. </td></tr>
    <tr><td class="paramname">FLAGS</td><td>See BASESORTFLAGS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Note that the classes that will be sorted have special requirements regarding <a class="el" href="movecopy.html">copy and move constructors </a>.</dd></dl>
<p>Example for traditional C-style arrays:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Sort1 : <span class="keyword">public</span> BaseSort&lt;Sort1&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__c4d__system__datatypes.html#ga76a8b016e5ad61faf9062cc387df5016">Bool</a> LessThan(<a class="code" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> a, <a class="code" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> b)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> a &lt; b;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Int array1[100];</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Sort1 sort1;</div><div class="line">sort1.Sort(&amp;array1[0], &amp;array1[100]); <span class="comment">// note that the &#39;end&#39; iterator is the last element + 1 and not the last element!</span></div><div class="line">sort1.Sort(array1, 100); <span class="comment">// even easier</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>LessThan can be a member of the sort class itself (not static), but needs to be const in that case.</dd></dl>
<p>Example for maxon arrays:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Sort2 : <span class="keyword">public</span> BaseSort&lt;Sort2&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__c4d__system__datatypes.html#ga76a8b016e5ad61faf9062cc387df5016">Bool</a> LessThan(<a class="code" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> a, <a class="code" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> b)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> a &lt; b;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">BlockArray&lt;<a class="code" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a>&gt; array2;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Sort2  sort2;</div><div class="line">sort2.Sort(array2.Begin(), array2.End()); <span class="comment">// do not write Sort(&amp;array2[0], &amp;array2[array2.GetCount()]) as this will create a debug assert (the second array access is illegal)</span></div><div class="line">sort2.Sort(array2); <span class="comment">// any arrays derived from BaseArray can be passed directly</span></div></div><!-- fragment --><p>Example for arbitrary structures with multiple sort criteria:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyStruct</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  String _str;</div><div class="line">  <a class="code" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a>    _index;</div><div class="line">  <a class="code" href="group__c4d__system__datatypes.html#gad79e2aa671fc9eec4d03a5c55eec6ee6">Float</a>  _weight;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Sort3 : <span class="keyword">public</span> BaseSort&lt;Sort3&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__c4d__system__datatypes.html#ga76a8b016e5ad61faf9062cc387df5016">Bool</a> LessThan(<span class="keyword">const</span> MyStruct&amp; a, <span class="keyword">const</span> MyStruct&amp; b)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (a._weight &lt; b._weight) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> (a._weight &gt; b._weight) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">return</span> a._index &lt; b._index; <span class="comment">// if weights are identical sort by index</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">BlockArray&lt;MyStruct&gt; array3;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Sort3  sort3;</div><div class="line">sort3.Sort(array3);</div></div><!-- fragment --><p>Searching Example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyStruct</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  String _str;</div><div class="line">  <a class="code" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a>    _index;</div><div class="line">  <a class="code" href="group__c4d__system__datatypes.html#gad79e2aa671fc9eec4d03a5c55eec6ee6">Float</a>  _weight;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>MySearch : <span class="keyword">public</span> BaseSort &lt;MySearch, BlockArray&lt;MyStruct&gt;::Iterator&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// for sorting: compare array element to array element</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__c4d__system__datatypes.html#ga76a8b016e5ad61faf9062cc387df5016">Bool</a> LessThan(<span class="keyword">const</span> MyStruct&amp; a, <span class="keyword">const</span> MyStruct&amp; b)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (a._weight &lt; b._weight) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> (a._weight &gt; b._weight) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">return</span> a._index &lt; b._index; <span class="comment">// if weights are identical sort by index</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// for searching: compare search key to array element</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__c4d__system__datatypes.html#ga76a8b016e5ad61faf9062cc387df5016">Bool</a> LessThan(<a class="code" href="group__c4d__system__datatypes.html#gad79e2aa671fc9eec4d03a5c55eec6ee6">Float</a> weight, <span class="keyword">const</span> MyStruct&amp; b)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> weight &lt; b._weight;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// for searching: compare search key to array element</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="group__c4d__system__datatypes.html#ga76a8b016e5ad61faf9062cc387df5016">Bool</a> IsEqual(<a class="code" href="group__c4d__system__datatypes.html#gad79e2aa671fc9eec4d03a5c55eec6ee6">Float</a> weight, <span class="keyword">const</span> MyStruct&amp; b)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> weight == b._weight;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">BlockArray&lt;MyStruct&gt; array4;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">MySearch search;</div><div class="line">search.Sort(array4);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// array is now sorted, we can search it</span></div><div class="line">MyStruct* result = search.Find(5.0, array4);</div></div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3dcc9c3a029b9332faa0aba1dc1937c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcc9c3a029b9332faa0aba1dc1937c4">&sect;&nbsp;</a></span>Sort() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sort </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort elements of an array, so that the smallest element comes first. Note that the sorting is not guaranteed to be stable (elements with the same sort value may change their order). The time for sorting is O(n * log(n)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start iterator of an array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end iterator of an array. Note that this is not the last element! It needs to be the boundary (which is last element + 1). See in the <a class="el" href="classmelange_1_1_base_sort.html">BaseSort</a> class description for examples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa7197dc59baf9bc383c3a4c945ce531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7197dc59baf9bc383c3a4c945ce531">&sect;&nbsp;</a></span>Sort() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sort </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort elements of an array, so that the smallest element comes first. Note that the sorting is not guaranteed to be stable (elements with the same sort value may change their order). The time for sorting is O(n * log(n)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start iterator of an array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of elements to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a747eed6bc2c1e89b92afa56cf9a80661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747eed6bc2c1e89b92afa56cf9a80661">&sect;&nbsp;</a></span>Sort() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sort </td>
          <td>(</td>
          <td class="paramtype">ARRAY &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort elements of an array, so that the smallest element comes first. Note that the sorting is not guaranteed to be stable (elements with the same sort value may change their order). The time for sorting is O(n * log(n)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>The array to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24bf1eb9bae6ace3de66327dd79a9cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bf1eb9bae6ace3de66327dd79a9cee">&sect;&nbsp;</a></span>Find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ITERATOR Find </td>
          <td>(</td>
          <td class="paramtype">const SEARCHTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an element in an array. The array must be in a sorted state. The time for searching will be O(log(n))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key that the array is searched for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>The array to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of elements of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element is found a pointer to it will be returned, otherwise the result is nullptr. If multiple elements have the same key value the first of those elements will be returned. </dd></dl>

</div>
</div>
<a id="a973efa4af8b35cc0e0e5a2bab263d998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973efa4af8b35cc0e0e5a2bab263d998">&sect;&nbsp;</a></span>Find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ARRAY::ValueType* Find </td>
          <td>(</td>
          <td class="paramtype">const SEARCHTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ARRAY &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an element in an array derived from <a class="el" href="classmelange_1_1_base_array.html">BaseArray</a>. The array must be in a sorted state. The time for searching will be O(log(n))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key that the array is searched for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>The array to be searched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element is found a pointer to it will be returned, otherwise the result is nullptr. If multiple elements have the same key value the first of those elements will be returned. </dd></dl>

</div>
</div>
<a id="aa1b4298b0710bcae7838837b4aa78880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b4298b0710bcae7838837b4aa78880">&sect;&nbsp;</a></span>FindInsertionIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ITERATOR FindInsertionIndex </td>
          <td>(</td>
          <td class="paramtype">const SEARCHTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an element in an array and return the insertion index if the element was not found. The array must be in a sorted state. The time for searching will be O(log(n))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key that the array is searched for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>The array to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of elements of the array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">insertionIndex</td><td>The index an element needs to be inserted at if it does not exist in the array. Inserting at the designated place ensures that the array stays sorted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element was found a pointer to it will be returned, otherwise the result is nullptr. If multiple elements have the same key value the first of those elements will be returned. </dd></dl>

</div>
</div>
<a id="a89075b16850204f451a683e67aea6b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89075b16850204f451a683e67aea6b2d">&sect;&nbsp;</a></span>FindInsertionIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ARRAY::ValueType* FindInsertionIndex </td>
          <td>(</td>
          <td class="paramtype">const SEARCHTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ARRAY &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an element in an array derived from <a class="el" href="classmelange_1_1_base_array.html">BaseArray</a> and return the insertion index if the element was not found. The array must be in a sorted state. The time for searching will be O(log(n))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key that the array is searched for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>The array to be searched. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">insertionIndex</td><td>The index an element needs to be inserted at if it does not exist in the array. Inserting at the designated place ensures that the array stays sorted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element was found a pointer to it will be returned, otherwise the result is nullptr. If multiple elements have the same key value the first of those elements will be returned. </dd></dl>

</div>
</div>
<a id="ae1df894890ba9c7eda8d5eaaea2fdbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1df894890ba9c7eda8d5eaaea2fdbb3">&sect;&nbsp;</a></span>Log2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a> Log2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad40a14bb5568ddb92c391eaeedb46cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40a14bb5568ddb92c391eaeedb46cea">&sect;&nbsp;</a></span>ISort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ISort </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c4d__system__datatypes.html#gadb5eb0bfb4b5a3bea55989bf2635cbf1">Int</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CONTENT &amp;&#160;</td>
          <td class="paramname"><em>valType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer -->
<!-- start footer part -->
<div id="nav-path" class="navpath"> <!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemelange.html">melange</a></li><li class="navelem"><a class="el" href="classmelange_1_1_base_sort.html">BaseSort</a></li>
    <li class="footer">Copyright &copy; 2017 MAXON Computer GmbH. Visit <a href="https://developers.maxon.net/" target="_blank" style="text-decoration:underline;">developers.maxon.net</a> for the latest version. Last updated on Fri Nov 17 2017</li>
  </ul>
</div>
</body>
</html>
<!-- end footer part -->